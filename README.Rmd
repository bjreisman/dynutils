---
output: md_document
editor_options: 
  chunk_output_type: console
---

```{r setup1, include=FALSE}
knitr::opts_chunk$set(fig.path = "man/figures/README_", warning = FALSE, message = FALSE, error = FALSE, echo = TRUE)
library(tidyverse)
library(dynutils)
```

# dynutils

[![Build Status](https://travis-ci.org/dynverse/dynutils.svg?branch=master)](https://travis-ci.org/dynverse/dynutils)
[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/dynverse/dynutils?branch=master&svg=true)](https://ci.appveyor.com/project/dynverse/dynutils)
[![CRAN_Status_Badge](https://www.r-pkg.org/badges/version/dynutils)](https://cran.r-project.org/package=dynutils)
[![Coverage Status](https://codecov.io/gh/dynverse/dynutils/branch/master/graph/badge.svg)](https://codecov.io/gh/dynverse/dynutils?branch=master)

Provides common functionality for the 'dynverse' packages. The functions in dynutils are showcased below, in no particular order.

'dynverse' is created to support the development, execution, and benchmarking of trajectory inference methods.
For more information, check out [github.com/dynverse/dynverse](https://github.com/dynverse/dynverse).

## Manipulation of lists
### `add_class`: Add a class to an object

```{r add_class}
l <- list(important_number = 42) %>% add_class("my_list")
l
```

### `extend_with`: Extend list with more data

```{r extend_with}
l %>% extend_with(
  .class_name = "improved_list", 
  url = "https://github.com/dynverse/dynverse"
)
```

## Distances
### `calculate_distance`: Compute pairwise distances between two matrices
See `?calculate_distance` for the list of currently supported distances.

```{r calculate_distance}
x <- matrix(runif(30), ncol = 10)
y <- matrix(runif(50), ncol = 10)
calculate_distance(x, y, method = "euclidean")
```

For euclidean distances, this is similar to calculating:
```{r dist}
as.matrix(dist(rbind(x, y)))[1:3, -1:-3]
```

## Manipulation of matrices
### `expand_matrix`: Add rows and columns to a matrix

```{r expand_matrix}
x <- matrix(runif(12), ncol = 4, dimnames = list(c("a", "c", "d"), c("D", "F", "H", "I")))
expand_matrix(x, letters[1:5], LETTERS[1:10], fill = 0)
```

## Scaling of matrices and vectors

### `scale_uniform`: Rescale data to have a certain center and max range.
Generate a matrix from a normal distribution with a large standard deviation, centered at c(5, 5).
```{r scale_uniform_gen}
x <- matrix(rnorm(200*2, sd = 10, mean = 5), ncol = 2)
```

Center the dataset at c(0, 0) with a minimum of c(-.5, -.5) and a maximum of c(.5, .5).
```{r scale_uniform}
x_scaled <- scale_uniform(x, center = 0, max_range = 1)
```

Check the ranges and verify that the scaling is correct.
```{r scale_uniform_verify}
ranges <- apply(x_scaled, 2, range)
ranges                   # should all lie between -.5 and .5
colMeans(ranges)         # should all be equal to 0
apply(ranges, 2, diff)   # max should be 1
```

### `scale_minmax`: Rescale data to a [0, 1] range
```{r scale_minmax}
x_scaled2 <- scale_minmax(x)
```

Check the ranges and verify that the scaling is correct.
```{r scale_minmax_verify}
apply(x_scaled2, 2, range)  # each column should be [0, 1]
```


### `scale_quantile`: Like minmax, but will cut off outer quantiles
```{r scale_quantile}
x_scaled3 <- scale_quantile(x, .05)
```

Check the ranges and verify that the scaling is correct.
```{r scale_quantile_verify}
apply(x_scaled3, 2, range)   # each column should be [0, 1]
plot(x_scaled2[,1], x_scaled3[,1])
```

## Manipulation of functions
### `inherit_default_params`: Have one function inherit the default parameters from other functions

```{r inherit_default_params}
fun1 <- function(a = 10, b = 7) runif(a, -b, b)
fun2 <- function(c = 9) 2^c

fun3 <- inherit_default_params(
  super = list(fun1, fun2),
  fun = function(a, b, c) {
    list(x = fun1(a, b), y = fun2(c))
  }
)

fun3
```

## Manipulation of packages
### `check_packages`: Easily checking whether certain packages are installed
```{r check_packages}
check_packages("SCORPIUS", "dynutils", "wubbalubbadubdub")
check_packages(c("princurve", "mlr", "tidyverse"))
```

### `install_packages`: Install packages taking into account the remotes of another

This is useful for installing suggested packages with GitHub remotes.

```{r install_packages, eval = FALSE}
install_packages("SCORPIUS", package = "dynmethods", prompt = TRUE)
```

```
> install_packages("SCORPIUS", package = "dynmethods", prompt = TRUE)
Following packages have to be installed: SCORPIUS
Do you want to install these packages? (y/yes/1 or n/no/2): 1
Installing SCORPIUS
...
** testing if installed package can be loaded
* DONE (SCORPIUS)
Installed SCORPIUS
[1] "SCORPIUS"
```

## Manipulation of character vectors

### `pritt`: A friendly version of `glue::glue`

```{r pritt}
a <- 10
pritt("a: {a}")

comparison <- glue::glue("a: {a}")
comparison            # glue::glue prints differently than base R
class(comparison)     # glue::glue adds a class to the output
```

### `random_time_string`: Generates a string very likely to be unique
```{r random_time_string}
random_time_string("test")

random_time_string("test")

random_time_string("test")
```

